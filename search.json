[{"title":"14.SpringBoot 集成分页插件 PageHelper","date":"2023-05-15T12:19:48.000Z","url":"/2023/05/15/14.SpringBoot%20%E9%9B%86%E6%88%90%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper/","tags":[["SpringBoot","/tags/SpringBoot/"],["分页插件","/tags/%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"],["PageHelper","/tags/PageHelper/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"SpringBoot 集成分页插件PageHelper 分页是一个项目中最基本的功能之一，当我们使用MyBatis进行数据库操作时，利用PageHelper可以很方便的帮我们完成分页功能的实现！ 1. 添加依赖 2. 添加配置application.yaml 3. 基本使用 4. 全局分页统一处理 事实上，第三步里已经完成了分页的实现了，只是返回的结果并不美观，且结果中的个别数据并不是我们常用的，所以说为了提升开发效率，就有必要进行统一处理 保留属性：当前页、每页数量、总页数、总条数、分页数据 定义分页统一处理类 CommonPage.java 控制器中调用示例： 至此，分页插件的集成就完成了！"},{"title":"13.SpringBoot 定义全局统一返回结果","date":"2023-05-11T12:19:48.000Z","url":"/2023/05/11/13.SpringBoot%20%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","tags":[["SpringBoot","/tags/SpringBoot/"],["全局统一返回结果","/tags/%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"SpringBoot 定义全局统一返回结果 在前后端分离的项目开发中，定义统一的返回结果格式可以提高开发的效率和沟通成本。 返回结构通常来说，返回结构中包含 code （返回码）、msg（返回消息说明）、data（返回数据），其中code、msg是强制要求返回数据的 格式如下： 返回码说明返回码一般会定义如下几种： 200 操作成功 500 操作失败 401 未登录或token过期 403 无访问权限 404 参数校验失败 当然，我们还可以根据项目需要定义自己的返回码即可 步骤说明第一步：定义返回码的接口 接口中规定两个方法：getCode、getMessage ErrorCode.java 第二步：定义返回码枚举类 ResultCode.java 第三步：定义返回结果统一生成类 关键一步，不然每次返回都得手动定义返回结果的结构 CommonResult.java "},{"title":"11.SpringBoot 整合统一异常处理","date":"2023-05-10T12:19:48.000Z","url":"/2023/05/10/11.SpringBoot%20%E6%95%B4%E5%90%88%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["SpringBoot","/tags/SpringBoot/"],["全局统一异常处理","/tags/%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"SpringBoot整合统一异常处理1. 背景首先要搞清楚为什么要进行统一的异常处理，不进行异常处理会发生什么？我们在开发的过程中，经常会遇到异常报错的情况，例如： 这个时候，对于我们的前端处理非常的不友好，因为返回的数据结构并不是统一的结果，不利于前端处理。那么这个时候我们就要对异常进行统一拦截，统一返回结果，方便异常记录和错误排查！ 2. 认识两个注解@RestControllerAdvice由@ReponseBody和@ControllerAdvice两部分组成。带有此注释的类型被视为控制器通知，其中@ExceptionHandler方法默认采用@ResponseBody语义，默认情况下，@ControllerAdvice中的方法全局应用于所有控制器 @ExceptionHandler用于处理特定处理程序类或处理程序方法中的异常，通常用来自定义异常的处理，可以认为它是一个异常拦截器。 @ExceptionHandler(xxx.class) 其中：xxx.class表示具体的异常类 3. SpringBoot 如何处理异常首先定义一个全局异常处理类，在类上加上@ControllerAdvice，然后在类里面通过@ExceptionHandler来对异常进行处理。 当前代码拦截了所有的异常，并通过统一返回结果类封装了返回结果，那么这个时候再看返回结果如下： 但是这样处理异常，范围有点太大了。如果我们想对某种异常进行单独的处理，那么我们再添加这种异常处理的方法就好了，就拿这个例子继续来说，增加一个更小范围的异常拦截 看结果： 可以看到，已经变成了我们预期的样子，说明我们的处理生效了。 关于@ControllerAdvice的文档说明 Specialization of @Component for classes that declare @ExceptionHandler, @InitBinder, or @ModelAttribute methods to be shared across multiple @Controller classes. 这个类是为那些声明了（@ExceptionHandler、@InitBinder 或 @ModelAttribute注解修饰的）方法的类而提供的专业化的@Component , 以供多个 Controller类所共享。 4. 自定义异常处理很简单，只要使用继承就可以了！ 在全局异常处理类中设置自定义异常拦截 设置断言处理类，用来处理各种自定义异常 使用场景如下： "},{"title":"12.SpringBoot 前后端分离项目跨域问题的处理","date":"2023-05-10T12:19:48.000Z","url":"/2023/05/10/12.SpringBoot%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86/","tags":[["SpringBoot","/tags/SpringBoot/"],["跨域","/tags/%E8%B7%A8%E5%9F%9F/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"SpringBoot 前后端分离项目跨域问题的处理1. 什么是跨域跨域资源共享是由同源策略引发的，首先要了解同源策略。而要了解同源策略先要了解什么是“源”。 1.1 不同源则触发一个跨域的HTTP请求在浏览器中，当 “一个资源” 向 “与它所在的服务器不同的域、协议或端口” 请求一个资源时，该资源会发起一个跨域 HTTP 请求。浏览器可能“限制发起跨域请求”，或者是 “可以发起跨域请求，但是返回结果被浏览器拦截”。 出于安全原因，浏览器限制跨源HTTP请求。这意味着使用 Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。 1.2 同源策略同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 也就是说，如果“源”相同，则运行访问。如果不同，则被限制。我们继续了解下什么是源 1.3 源源由三部分组成： 协议 主机（域名） 端口 只要三部分其中之一不一致，就是不同源。 浏览器的同源策略提升了安全性，然而在业务需求中仍然需要“访问不同源的资源”，于是提出了“CORS机制”。 现代浏览器支持使用 CORS，以降低跨域 HTTP 请求所带来的风险。CORS 机制允许 Web应用 进行跨域访问控制，从而使跨域数据传输得以安全进行。 2. CORS机制2.1 简介CORS机制就是使用额外的 HTTP头 来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的资源 跨域资源请求分为： 服务器通过请求头来声明“允许的源站，和允许的资源” 预检请求 携带身份凭据（cookie等）的情形 2.2 一次完整的跨域请求1. 先发起一次OPTIONS请求进行预检 请求 响应 请求成功返回状态码 200 2. 发起真实的跨域请求 请求 响应 请求成功返回状态码 200 3. 解决方案3.1 覆盖默认的CorsFilter来解决该问题 添加GlobalCorsConfig配置文件来允许跨域访问 3.2 设置SpringSecurity允许OPTIONS请求访问设置完上面后，发现OPTIONS预检请求无法通过认证，则说明SpringBoot 整合的 SpringSecurity 没有对OPTION请求放开认证。那么我们就需要进行如下代码： "},{"title":"10.SpringBoot 整合 MinIo 对象存储服务","date":"2023-05-08T12:19:48.000Z","url":"/2023/05/08/10.SpringBoot%20%E6%95%B4%E5%90%88%20MinIo%20%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/","tags":[["SpringBoot","/tags/SpringBoot/"],["MinIo","/tags/MinIo/"],["对象存储","/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"MinIo简介MinIO是在GNU Affero通用公共许可证v3.0下发布的高性能对象存储。API兼容Amazon S3云存储服务。使用MinIO为机器学习、分析和应用程序数据工作负载构建高性能基础架构。对象存储服务可以用来存储各类文件，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等。 安装部署方式很多，这里使用docker安装方式 下载MinIo的docker镜像 在Docker容器中运行MinIO，这里我们将MiniIO的数据和配置文件夹挂载到宿主机上 访问127.0.0.1:9090 出现如下图界面表示成功，输入默认用户名密码登录即可。用户名和密码都是：minioadmin 创建Access Key 和 Secret Key accessKey : HLWj5NpOQ2bB9wYcXqhK secretKey: MzUH4UPnDUh3cGpbIQVRAtONLC7th0N9jnR1OFF7 上传文件及使用 通过使用MinIO的网页端即可完成文件的上传下载功能，下面我们以图片上传下载为例来演示下该功能 在存储文件之前，我们需要新建一个存储桶： 存储桶创建完成后，通过上传按钮可以上传文件，这里我们上传一张图片： 设置访问策略 这里有三种访问策略可以选择，一种只读、一种只写、一种可读可写，这里我们选择只读即可，但是需要注意的是，访问前缀需要设置为*.*，否则会无法访问； 设置完成后就可以通过地址永久访问了 访问效果 Spring boot 整合 Minio上传流程 整合 在pom.xml中添加MinIO的相关依赖： 在SpringBoot中开启文件上传功能，需要在application.yml添加如下配置： 添加一个MinioController控制器用于实现文件的上传和删除操作 在application.yml中对MinIO客户端进行配置： 启动我的SpringBoot应用，使用Postman来访问上传接口进行文件上传，上传接口地址:127.0.0.1:8080&#x2F;minio&#x2F;upload 上传完成 "},{"title":"09.Spring Security入门","date":"2023-05-06T12:19:48.000Z","url":"/2023/05/06/09.Spring%20Security%E5%85%A5%E9%97%A8/","tags":[["Spring Security","/tags/Spring-Security/"],["用户授权集成","/tags/%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E9%9B%86%E6%88%90/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"Spring Security入门1. 认识认证流程 关键实现类： UsernamePasswordAuthenticationFilter ProviderManager DaoAuthenticationProvider InMemoryUserDetailsManager 1.1 认证流程 提交用户名和密码 封装Authentication对象，注意此处还没有权限 调用authenticate方法进行认证 调用DaoAuthenticationProvider的authenticate方法进行认证 调用loadUserByUsername方法查询用户 5.1 根据用户名去查询对应的用户及该用户对应的权限，InMemoryUserDetailsManager是在内存中查找 5.2 把对应的用户信息和权限信息封装到UserDetails对象 返回UserDetails对象 通过PasswordEncode对比UserDetails中的密码 和 Authentication 的密码是否正确 如果正确就把UserDetails中的权限信息设置到Authentication对象中 返回Authentication对象 如果上一步返回了Authentication对象，就使用 SecurityContextHolder.getContext().setAuthentication方法存储该对象。其他过滤器中会通过SecurityContextHolder来获取当前用户信息 2. 入门2.1 引入依赖 2.2 定义控制器 Controller 2.3 定义 service接口及实现类接口 实现类 2.4 定义UserDetailsService接口实现类 2.5 定义Dao接口及Mapper配置文件采用MyBatis框架做持久层 引入依赖 接口 mapper配置文件 配置mybatis生效配置文件 MyBatisConfig.java 2.5 定义UserDetails接口实现类作用：todo…. 2.6 定义security配置文件 2.7 定义数据表实体类 2.8 工具类JwtUtil.java作用：生产及验证token ErrorCode.java错误码接口 作用：用来规范错误码的实现 ResultCode.java返回码类，用来实现错误码 CommonResult.java返回结果格式定义类，用来统一接口返回结果，方便前端统一处理 自定义失败处理定义无论是认证失败还是授权失败后能和接口一样返回同样格式的 json ,这样能让前端对响应结果进行统一处理。 在Spring Security中，如果在认证或者授权的过程中出现了异常会被***ExceptionTranslationFilter*捕获到，然后ExceptionTranslationFilter**会去判断是认证失败还是授权失败产生的异常。 如果是认证过程中产生的异常，会被封装成**AuthenticationException，然后调用AuthenticationEntryPoint**对象的方法进行异常处理。 如果是授权过程中产生的异常，会被封装成**AccessDeniedException，然后调用AccessDeniedHandler**对象的方法去处理异常。 所以说要自定义失败处理，那么只需要自定义**AuthenticationEntryPoint和AccessDeniedHandler**，然后配置给Spring Security即可 认证失败处理 引入json工具类 自定义类，实现 AuthenticationEntryPoint 接口 配置到Spring Security 关键代码 全部配置 授权失败处理"},{"title":"08.JWT 的使用","date":"2023-05-05T12:19:48.000Z","url":"/2023/05/05/08.JWT%20%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["Java","/tags/Java/"],["JWT","/tags/JWT/"],["JWS","/tags/JWS/"],["JWK","/tags/JWK/"],["JWE","/tags/JWE/"],["JWA","/tags/JWA/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"什么是JWT、JWS、JWE、JWK、JWA前言Learn about the JOSE framework and its specifications, including JSON Web Token (JWT), JSON Web Signature (JWS), JSON Web Encryption (JWE), JSON Web Key (JWK), and JSON Web Algorithms (JWA) 了解 JOSE 框架及其规范，包括 JSON Web 令牌 (JWT)、JSON Web 签名 (JWS)、JSON Web 加密 (JWE)、JSON Web 密钥 (JWK) 和 JSON Web 算法 (JWA) JSON（JavaScript 对象表示法）是一种基于文本、独立于语言的格式，易于人类和机器理解。 JOSE（Javascript 对象签名和加密）是一个用于促进任意两方之间安全传输声明的框架。它的规范提供了一种对任何内容（不一定是 JSON）进行加密的通用方法。然而，它是基于 JSON 构建的，以便于在 Web 应用程序中使用。 JWT - JSON Web TokenJWT 是用于身份验证的标准机制。它是紧凑且 URL 安全的，用于表示在两方之间传输的声明。声明是一组键&#x2F;值对，它们为目标系统提供有关客户端的信息，以对其资源应用适当级别的访问控制。声明名称可以是注册名称 (IANA)、公共名称或私有名称。一些注册的声明名称是： “iss”：发行人声明 — 标识声明的发行人 “sub”：主题声明 — 标识声明的主题 “jti”：JWT ID — 唯一标识声明 结构JWT主要由三部分组成：头部、有效负载和签名，这些部分都是Base64 URL编码的。 标头用于标识用于生成签名的算法。 有效负载由用于验证令牌的声明和签名（密钥）组成。 发送信息的结构可以是序列化或反序列化。在序列化形式中，JWT 表示为包含标头、有效负载和由点分隔的签名的字符串。 下面是一个简单的JWT例子： Json Web Token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTIzNDU2Nzg5LCJuYW1lIjoiSm9zZXBoIn0.OpOSSw7e485LOP5PrzScxHb7SR6sAOMRckfFwi4rp7o 这显示了解码后的 JSON Web Token。在反序列化形式中，JWT 仅包含Header和Payload作为纯 JSON 对象。 JWT是使用JWS或JWE实现的。 JWS - JSON Web SignatureJWS 用于在 JSON 数据结构的帮助下表示通过数字签名或基于哈希的消息身份验证代码 (HMAC) 保护的内容。它使用 JWS 签名以加密方式保护 JWS Header和 JWS Payload。这三个的编码字符串使用类似于 JWT 的点连接起来。使用的标识符和算法在 JSON Web 算法规范中指定。 JWS Header必须包含 alg 参数，因为它使用算法对 JWS 标头和 JWS 有效负载进行编码以生成 JWS 签名。对 JWS 标头和负载进行签名的一些常用算法包括： 使用 SHA-256 或 SHA-512 哈希算法的 HMAC（HS256、HS512） 使用 SHA-256 或 SHA-512 哈希算法的 RSA（RS256、RS512） JWS的例子： 它有一个编码的 JWS Header，后跟一个由“.”分隔的编码的 JWS Payload。 这是 JWS 签名输入，在使用 HMAC SHA-256 算法和 base64url 编码进行签名时，会给出编码的 JWS 签名值： 然后连接起来就是一个整体了 JWE - JSON Web EncryptionJSON Web Encryption 可以对 token 进行加密，以便只有预期的收件人才能读取它。它标准化了 JSON 数据结构中编码数据的表示方式。加密Payload的表示可以是 JWE compact serialization 或 JWE JSON serialization。 结构JWE compact serialization 形式有五个主要组成部分： JOSE Header JWE Encrypted Key JWE initialization vector &#x2F;&#x2F;初始化向量 JWE Ciphertext JWE Authentication Tag 所有这些组件均经过 base64url 编码并使用点 ( .) 连接。 JOSE Header（令牌的第一个元素）与前面提到的 JWT 和 JWS 的标头相同。 JWE 在Header中还有附加元素 —enc和zip. enc定义内容加密算法，而元素定义内容加密密钥 (CEK)alg的加密算法。 zip如果需要令牌压缩，则提供压缩算法。 在加密过程中，发行者会生成一个大小为 256 位的随机密钥，用于加密消息。它位于 JWE Encrypted key 部分。 一些加密算法需要一个初始化向量，它是一个随机生成的数字，与密钥一起使用来加密数据。这可以防止使用相同的密钥重复加密相同的数据。接收者需要此初始化向量来解密消息，因此被放置在 JWE Token中。 token的第四部分是通过加密明文 JSON Payload 计算出的 JWE 密文。它使用标头元素中提到的算法enc。 JWE Authentication Tag 是与密文一起生成的 JWE Token 的最后部分。它保证了密文的完整性。 JWK - JSON Web KeyJWK 是一种 JSON 结构，使用椭圆曲线 或 RSA 算法将一组公钥表示为 JSON 对象。公钥表示可以帮助用相应的私钥验证签名。 结构JWK 由 JWK 容器对象和 JWK 密钥对象数组组成。 JWK 容器对象是一个 JSON 对象，其中包含作为数组的特定成员。该成员是容器对象中必需的元素。 JWK 密钥对象存储在 JWK 容器对象的数组中。它们有一组所有键类型都通用的成员。如前所述，JWK Key 对象可以使用椭圆曲线或 RSA 算法。为此，该alg字段必须分别包含EC或RSA。以下是使用 RSA 的 JWK 示例： 它提供一个用于匹配的密钥 ID。 JWA — JSON Web AlgorithmsJWA规范主要集中于枚举JWS、JWK和JWE所需的算法。它还描述了特定于这些算法和密钥类型的操作。 JWS 算法：这些算法用于对 JWS 标头和 JWS 有效负载的内容进行签名 JWE 算法：这些算法对内容加密密钥 (CEK) 进行加密并生成 JWE 加密密钥 JWK 的算法： JWA 指定了一组用于 JWK 表示的公钥的算法系列 JWT的使用前言JWT 主要用于用户登录鉴权，针对前后端分离的项目，大多是通过 token 进行身份认证来进行交互，今天将介绍一种简单的创建 token 的方式 – JWT 基本介绍2.1 定义JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。 2.2 组成部分一个 JWT 实际上就是一个字符串，它由三部分组成，头部、载荷、签名。前两部分需要经过 Base64 编码，后一部分通过前两部分 Base64 编码后再加密而成 2.2.1 头部（Header）JWT 第一部分是头部分，它是一个描述 JWT 元数据的 Json 对象，通常头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等 例如： alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为HS256），typ 属性表示令牌的类型，JWT 令牌统一写为JWT。 最后，使用Base64 URL 算法将上述 JSON 对象转换为字符串保存 2.2.2 载荷（playload）JWT 第二部分是 Payload，也是一个 Json 对象。这部分是存放有效信息的地方，这些有效信息包含三个部分 标准中注册的声明（建议但不强制使用） 公共的声明（自定义声明） 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为默认情况下 JWT 是未加密的，任何人都可以解读其内容，即使加密了在客户端也是可以解密的。例如： 该JSON 对象也是使用 Base64 URL 算法转换为字符串后保存，是可以反向反编码回原样的，这也是为什么不要在 JWT 中放敏感数据的原因 私有的声明 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64 是对称解密的，意味着该部分信息可以归类为明文信息 注意：载荷中的这3个声明并不是都要同时设置。 2.2.3 签名（signature）JWT的第三部分是一个签证信息。 这个部分需要 Base64 加密后的 header 和 Base64 加密后的 payload 使用 “.” 连接组成的字符串，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 JWT 的第三部分。 由于 secret 仅仅保存在服务器中，保证不能让其他用户知道，所以避免了反向解密 那么服务端是如何进行验证的呢？ 利用 JWT 前两段，用同一套哈希算法和同一个 secret 计算一个签名值，然后把计算出来的签名值和收到的 JWT 第三段比较，如果相同则认证通过。 2.3 JWT 的优点 json格式的通用性，所以JWT可以跨语言支持，比如Java、JavaScript、PHP、Node等等。 可以利用Payload存储一些非敏感的信息。 便于传输，JWT结构简单，字节占用小。 不需要在服务端保存会话信息，易于应用的扩展。 实战通过上述的介绍，我们已经了解到什么是 JWT 以及 JWT 生成的规则，现在我们通过代码方式来生成 JWT。 JWT 官网提供了通过不同编程语言来创建 JWT 的工具类&#x2F;库，此次测试我们选用 JJWT 。 3.1 引入依赖 3.2 创建工具类用于创建(生成) jwt 字符串和解析 jwt JwtUtil.java application.yaml 3.3 测试类 "},{"title":"07.数据库连接池","date":"2023-05-03T12:19:48.000Z","url":"/2023/05/03/07.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","tags":[["Spring Boot","/tags/Spring-Boot/"],["数据库连接池","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"],["Druid","/tags/Druid/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"数据库连接池 Druid (德鲁伊)1. JDBC数据库连接池的必要性在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤 1）在主程序（如servlet、beans）中建立数据库连接 2）进行sql操作 3）断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求 一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很 好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严 重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统 中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内 存泄漏，服务器崩溃 数据库连接池技术为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 2. 基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要 建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重 新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库 连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池 的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连 接数量时，这些请求将被加入到等待队列中。 3. 优点1） 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一 方面也增加了系统运行环境的平稳性。 2） 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均 已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销， 从而减少了系统的响应时间 3） 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库 连接数的限制，避免某一应用独占所有的数据库资源 4） 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据 库连接操作中可能出现的资源泄露 4. DataSourceDataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接 池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速 度。 特别注意：数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个 数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数 据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 5. Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了 日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的 连接池之一。 常用配置项： 配置项 默认 说明 initial-size 0 初始化时建立的物理连接个数 max-active 8 最大连接数 min-idle 最小连接数 "},{"title":"05.SpringMVC","date":"2023-04-30T12:19:48.000Z","url":"/2023/04/30/05.SpringMVC%20/","tags":[["Spring","/tags/Spring/"],["SpringMVC","/tags/SpringMVC/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]]},{"title":"06.Spring Boot","date":"2023-04-30T12:19:48.000Z","url":"/2023/04/30/06.SpringBoot/","tags":[["Spring Boot","/tags/Spring-Boot/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"Spring Boot简介：Spring Boot创建可以运行的独立的、基于Spring的生产级应用程序。可以轻松入门。大多数Spring Boot应用程序只需要很少的Spring配置 本文基于 Spring Boot 2.7.11 1. 快速入门 jdk8及以上 Spring Framework 5.3.27及以上 Maven 3.5 + 1.1 创建一个Maven工程pom.xml 1.2 开发第一个应用创建一个java入口文件 MyApplication.java 至此，在IDEA中点击运行即可使用 localhost:8080访问 hello world 1.3 创建可执行jar包要创建一个可执行的jar，我们需要将spring-boot-maven-plugin添加到pom.xml中。为此，在依赖项部分下面插入以下几行 执行mvn package完成打包 在target目录下生成了Springboot-1.0-SNAPSHOT.jar 在命令行运行如下命令即可 结果如下： 2. 注解2.1 @Configuration 注解 配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的 配置了本身也是组件 proxyBeanMethods：代理bean对象 ​ Full( proxyBeanMethods &#x3D; true ) 全量模式 ，设为true表示从容器中去寻找创建的对象 ​ Lite( proxyBeanMethods &#x3D; false ) 轻量模式，设为false表示重新创建一个新的对象 2.2 @Import 注解 给容器中自动引入类组件，默认组件的名字就是全类名 2.3 @Conditional条件装配 @ConditionalOnBean 如果容器中存在指定类，则注入当前注解修饰的这个bean，否则不注入 @ConditionalOnMissingClass 如果容器中不存在指定的类，则注入当前注解修饰的类 2.4 @ImportResource 注解 2.5 @ConfigurationProperties自动绑定配置文件中的初始值 application.properties 方式一 作用在Bean类上 方式二 作用在配置类上 3. Developer Toolsspring-boot-devtools模块可以包含在任何项目中，以提供额外的开发时特性。要包含devtools支持，将模块依赖项添加到构建中 快捷键 command + F9 工具栏：构建-》构建项目 作用：检测代码变化后自动构建，可以认为是热更新，实质还是重新运行项目 4. 神器 Spring Initailizr项目初始化向导 IDEA创建Springboot项目神器：工具栏-》文件-》新建-》项目-》Spring Initailizr 5. yaml配置文件详解5.1 基本介绍1）YAML是 JSON 的超集，简洁而强大，是一种专门用来书写配置文件的语言，可以替代 application.properties 2）在创建一个 SpringBoot 项目时，引入的 spring-boot-starter-web 依赖间接地引入了 snakeyaml 依赖， snakeyaml 会实现对 YAML 配置的解析 3）YAML 的使用非常简单，利用缩进来表示层级关系，并且大小写敏感。 5.2 YAML 配置与Properties 配置的比较1）可以使用 @PropertySource 注解加载自定义的 Properties 配置文件，但无法加载自定义的 YAML 文件 2）YAML 支持列表的配置，而 Properties 不支持 5.3 语法结构 key: value； kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许tab,只允许空格 缩进的格数不重要，只要相同层级的元素左对齐即可 #号表示注释 单引号与双引号表示的字符串内容 会被 转义&#x2F;不转义 5.4 数据类型 字面量：单个的、不可再分的值。date、boolean、string、number、null 对象：键值对的集合。map、hash、set、object 数组：一组按次序排列的值。array、list、queue 5.5 示例Person.java Pet.java application.yaml 5.6 配置提示功能5.6.1 引入依赖 5.6.2 打包排除当前依赖 6. Web 开发6.1 简单功能分析6.1.1 静态资源访问1. 静态资源目录 类路径下：called &#x2F;static (or &#x2F;public or &#x2F;resources or**&#x2F;META-INF&#x2F;resources**） 2.静态资源访问前缀 默认：无前缀 6.1.2 欢迎页Spring Boot支持静态和模板化的欢迎页面。它首先在配置的静态内容位置中查找index.html文件。如果没有找到，则查找索引模板。如果找到任何一个，它将自动用作应用程序的欢迎页面 如果配置类静态资源访问前缀，则欢迎页失效 6.1.3 favicon.ico与其他静态资源一样，Spring Boot在配置的静态内容位置中检查favicon.ico。如果存在这样的文件，它将自动用作应用程序的图标 如果配置类静态资源访问前缀，则favicon.ico失效 6.2 请求参数处理6.2.1 请求映射核心Filter: HiddenHttpMethodFilter Springboot 配置类 WebMvcAutoConfiguration.java 使用REST风格，需要在配置文件中开启下面的配置 测试 6.2.2 普通参数与基本注解注解： @PathVariable 路径变量 @RequestHeader 请求头信息 @RequestParam 获取请求参数 @CookieValue 获取cookie @RequestBody 获取post请求体数据 @RequestAttribute 获取请求域属性，通常用于跳转后到新页面获取携带信息 @MatrixVariable 矩阵变量 配置类 控制器类 前端代码 Servlet API WebRequest ServletRequest MultipartRequest HttpSession javax.servlet.http.PushBuilder Principal InputStream Reader HttpMethod Locale TimeZone ZoneId 复杂参数 Map 可以给request域中放数据 Errors&#x2F;BindingResult Model 可以给request域中放数据 RedirectAttributes 重定向携带数据 ServletResponse 可以给request域中放数据 SessionStatus UriComponentsBuilder ServletUriComponentsBuilder 6.4 响应数据与内容协商6.5 视图解析与模版引擎6.6 拦截器6.7 跨域6.8 异常处理6.9 原生组件注入6.10 嵌入式Web容器6.11 定制化原理"},{"title":"04.Spring 整合 MyBatis","date":"2023-04-29T12:19:48.000Z","url":"/2023/04/29/04.Spring%20%E6%95%B4%E5%90%88MyBatis/","tags":[["Spring","/tags/Spring/"],["MyBatis","/tags/MyBatis/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"Spring 整合 MyBatis任何框架整合Spring的目的只有一个：把该框架常用的工具对象交给 Spring 管理，要用的时候去容器中取m ybatis 工具对象； 1. 入门示例 在resources目录下创建数据库配置文件（db.properties） 引入相关依赖 准备pojo类 准备dao接口 数据访问层，具体到对于某个表的增删改查，也就是说某个DAO一定是和数据库的某一张表一一对应的，其中封装了增删改查基本操作 准备Mapper映射文件 UserMapper.xml 与Dao接口中的方法一一对应 service层 服务层，被称为服务，粗略的理解就是对一个或多个DAO进行的再次封装，封装成一个服务，通常先设计接口，再创建实现类，接下来就可以在service层调用接口进行业务逻辑应用的处理。 接口 实现类 创建整合配置文件ApplicationConfig.xml 测试 "},{"title":"03.Spring 整合 Junit","date":"2023-04-28T12:19:48.000Z","url":"/2023/04/28/03.Spring%20%E6%95%B4%E5%90%88Junit/","tags":[["Spring","/tags/Spring/"],["Junit","/tags/Junit/"],["单元测试","/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"Spring 整合Junit1. 整合 Junit51.1 引入依赖 1.2 配置bean 1.3 创建类 1.4 测试 2. 整合 Junit42.1 引入依赖 2.2 测试"},{"title":"02.Spring 面向切面 AOP","date":"2023-04-27T12:19:48.000Z","url":"/2023/04/27/02.Spring%20%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2AOP/","tags":[["Spring","/tags/Spring/"],["AOP","/tags/AOP/"],["面向切面","/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"Spring 面向切面 AOP1. 入门案例定义接口 定义实现类 代理类 测试 2.概念和术语2.1 概念AOP 从程序运行的角度考虑程序的流程，提取业务处理过程的切面。AOP 面向的是程序运行的各个步骤，希望以更好的方式来组合业务处理的各个步骤。AOP 框架不与特定的代码耦合，它能处理程序执行中特定的切入点（Pointcut）,而不与某个具体类耦合。 特征 各步骤之间的良好隔离性 源代码无关性 2.2 术语 术语 名称 解释 Aspect 切面 用于组织多个Advice，Advice被放在切面中定义。 Joinpoint 连接点 程序执行过程中明确的点，如方法的调用或者异常的抛出。在Spring AOP中，连接点总是方法的调用 Advice 增强处理 AOP框架在特定的切入点执行的增强处理。处理有“around” “before” “after” 等类型 Pointcut 切入点 可以出入增强处理的连接点。 引入 将方法或字段添加到被处理的类中 目标对象 被AOP框架进行增强处理的对象，也被称为被增强的对象 AOP代理 AOP框架创建的对象 Weaving 织入 将增强处理添加到目标对象中，并创建一个被增强的对象的过程就是织入。 2.3 基于注解的AOP2.3.1 实验一 引入依赖 创建目标资源 1)接口 创建切面类并配置 1)切面类 ​ 2)配置文件 注意引入xml依赖 测试 2.3.2 重用切入点表达式 声明 在同一切面中使用 在不同切面中使用 2.3.3 切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用@Order注解可以控制切面的优先级 @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 2.4 基于XML的AOP2.4.1 实验一1.准备工作 参考基于注解的AOP 2.配置文件 "},{"title":"01.Spring-IoC 控制反转","date":"2023-04-26T11:19:48.000Z","url":"/2023/04/26/01-Spring-IoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","tags":[["Spring","/tags/Spring/"],["IoC","/tags/IoC/"],["控制反转","/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["01-Spring学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"content":"Spring IoC控制反转概念IoC作用：Spring 通过IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系 我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别 依赖注入DI (Dependency Injection) 依赖注入 IoC 是思想，DI 是实现 概念： 指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 基于XML管理bean入门案例TestUser.java beans.xml User.java 获取bean的三种方式 根据ID获取 根据class获取 根据id和class获取 扩展知识 如果组件类实现了接口，根据接口类型可以获取bean吗? 可以 如果一个接口有多个实现类，这些实现类都配置了bean，那么根据接口类型可以获取bean吗？ 不可以，因为bean不唯一 注入方式原生注入方法： 第一种：set注入 第二种：构造注入 特殊属性类型注入 对象类型属性注入 关键字 ref ​ 数组类型属性注入 关键字 array ​ 集合类型属性注入 1）list集合 ​ 2）map集合 ​ 3）引用集合类型的bean 需要在xml中增加相关约束 ​ 4）p命名空间注入 引入外部文件注入 常见场景：数据库配置文件 1）引入相关依赖 2）创建外部属性文件jdbc.properties 3）创建spring配置文件，引入context命名空间，引入属性文件，使用表达式完成注入 4）配置bean 5）测试 bean的作用域1）概念 在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围 取值 含义 创建对象的时机 singleton 在IoC容器中，这个bean的对象始终为单实例 IoC容器初始化 prototype 这个bean在IoC容器中有多个实例 获取bean时 bean的生命周期1）调用无参数构造器，创建bean对象 2）给bean对象设置属性值 3）bean后置处理器（初始化之前） 4）bean对象初始化（调用指定的初始化方法） 5）bean后置处理器（初始化之后） 6）bean对象创建完成了，可以使用了 7）bean对象销毁（配置指定销毁的方法） 8）IoC容器关闭 第一步：创建类 User.java MyPost.java 第二步：配置bean 第三步：测试 FactoryBean简介：FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节屏蔽起来，只把最简洁的使用界面展示给我们。 将来我们整合MyBatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。 1）创建类UserFactoryBean 2）配置bean 3）测试 基于xml自动装配 根据指定的策略，在IoC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值 基于注解管理bean概念代码中的一种特殊标记，格式：@注解名称(属性1&#x3D;属性值…)；简化Spring的XML配置； Spring 通过注解实现自动装配的步骤如下： 引入依赖 开启组件扫描 使用注解定义Bean 依赖注入 引入依赖 注意：logback.xml放在resource下，内容如下： 开启组件扫描新建beans.xml，引入context命名空间，开启组件扫描。开启扫描后，Spring会自动扫描配置路径下的所有java类，并创建Bean实例 使用注解定义BeanSpring提供了以下几个注解来标注Spring Bean @Component：标注一个普通的Spring Bean类 @Controller：标注一个控制器组件类 @Service：标注一个业务逻辑组件类 @Repository：标注一个DAO组件类 依赖注入@Autowired 属性注入 setter方法注入 构造方法注入 形参上注入 @Autowired注解和@Qualifier注解联合实现 按名称自动注入 全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件 配置类 测试类 "}]